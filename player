using System.Collections;
using UnityEngine;

public class Player : MonoBehaviour
{
    [Header("Configuración de movimiento")]
    public bool carriles = false;
    public bool autoPilot = false;
    [SerializeField] private int cantCarriles = 3;
    [SerializeField] private float movementDistance = 6.0f;
    [SerializeField] private float limitY = -3.5f;
    [SerializeField] private float limitX = 8.10f;
    private float[] posCarriles;
    
    public float speed = 8;
    private float originalSpeed;

    [SerializeField] private bool puedeVolar = false;

    [Header("Configuración de vida")]
    public int life = 3;
    public bool inmunity = false;

    [Header("Configuración generales")]
    [SerializeField] private Configuracion_General config;

    private bool isSyncMomentActive = false;
    private KeyCode[] syncKeys = { KeyCode.A, KeyCode.S, KeyCode.D, KeyCode.W };

    void Start()
    {
        life = config.vidas;
        speed = config.velocidad;
        originalSpeed = speed;

        InitializeCarriles();
    }

    void Update()
    {
        Movement();
    }

    private void InitializeCarriles()
    {
        if (carriles)
        {
            posCarriles = cantCarriles switch
            {
                2 => new float[] { -movementDistance, 0, movementDistance },
                3 => new float[] { -movementDistance, movementDistance },
                _ => throw new System.Exception("Cantidad de carriles inválida.")
            };
        }
    }

    private void Movement()
    {
        if (carriles)
        {
            HandleCarrilesMovement();
        }
        else
        {
            HandleFreeMovement();
        }

        if (autoPilot)
        {
            transform.Translate(Vector3.forward * speed * Time.deltaTime);
        }
    }

    private void HandleCarrilesMovement()
    {
        float playerPosition = transform.position.x;

        if (Input.GetKeyDown(KeyCode.D) && playerPosition < posCarriles[1])
        {
            transform.Translate(movementDistance, 0, 0);
        }
        else if (Input.GetKeyDown(KeyCode.A) && playerPosition > posCarriles[0])
        {
            transform.Translate(-movementDistance, 0, 0);
        }
    }

    private void HandleFreeMovement()
    {
        float horizontalInput = Input.GetAxis("Horizontal");
        transform.Translate(Vector3.right * speed * horizontalInput * Time.deltaTime);
        ConstrainPosition();

        if (puedeVolar)
        {
            float verticalInput = Input.GetAxis("Vertical");
            transform.Translate(Vector2.up * speed * verticalInput * Time.deltaTime);
            ConstrainPositionY();
        }
    }

    private void ConstrainPosition()
    {
        transform.position = new Vector3(
            Mathf.Clamp(transform.position.x, -limitX, limitX),
            transform.position.y
        );
    }

    private void ConstrainPositionY()
    {
        transform.position = new Vector2(
            transform.position.x,
            Mathf.Clamp(transform.position.y, limitY, 0)
        );
    }

    private void OnTriggerEnter(Collider obj)
    {
        switch (obj.gameObject.tag)
        {
            case "Basura":
                ApplyDamage(1);
                break;
            case "BasuraRadioactiva":
                ApplyDamage(2);
                break;
            case "MuroBasura":
                ActivateSyncMoment();
                break;
            case "BoostVelocidad":
                BoostSpeed();
                Destroy(obj.gameObject);
                break;
            case "Borde":
                ReduceSpeed(0.85f);
                break;
            case "BoostVida":
                life++;
                Destroy(obj.gameObject);
                break;
        }
    }

    private void ActivateSyncMoment()
    {
        isSyncMomentActive = true;
        StartCoroutine(SyncMomentRoutine());
    }

    private IEnumerator SyncMomentRoutine()
    {
        yield return new WaitForSeconds(1f);

        foreach (KeyCode key in syncKeys)
        {
            if (Input.GetKeyDown(key))
            {
                if (key == GetOtherPlayerInput())
                {
                    isSyncMomentActive = false;
                    Debug.Log("Momento sincro completado correctamente.");
                    yield break;
                }
            }
        }
        GameOver();
    }

    private KeyCode GetOtherPlayerInput()
    {
        // Método de simulación; en un entorno multijugador, sincronizaría la entrada del otro jugador.
        return KeyCode.A;
    }

    private void ApplyDamage(int damage)
    {
        if (inmunity) return;

        life -= damage;
        if (life <= 0)
        {
            config.perdiste = true;
            Destroy(gameObject);
        }
        else
        {
            config.vidas = life;
        }
    }

    private void BoostSpeed()
    {
        speed *= 1.5f;
    }

    private void ReduceSpeed(float factor)
    {
        speed *= factor;
    }

    private void GameOver()
    {
        Debug.Log("¡Juego terminado!");
    }
}
